name: Shell Script Quality Checks

on:
  push:
    branches:
      - main
  pull_request:

jobs:
  lint-and-format:
    name: Lint and Format
    runs-on: ubuntu-latest
    container: alpine/git:latest

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Install Dependencies
        # Install bash for logic handling, coreutils for GNU sha256sum, and linters.
        run: |
          apk add --no-cache shellcheck curl bash coreutils
          mkdir -p /usr/local/bin

      - name: Download and Validate shfmt
        env:
          SHFMT_VERSION: v3.8.0
        shell: bash
        run: |
          set -eo pipefail

          printf "Downloading shfmt %s...\n" "${SHFMT_VERSION}"

          # Download binary and checksums with fail-fast on HTTP errors.
          curl --fail -sL "https://github.com/mvdan/sh/releases/download/${SHFMT_VERSION}/shfmt_${SHFMT_VERSION}_linux_amd64" -o /usr/local/bin/shfmt
          curl --fail -sL "https://github.com/mvdan/sh/releases/download/${SHFMT_VERSION}/sha256sums.txt" -o /tmp/sha256sums.txt

          printf "Verifying shfmt checksum...\n"

          # Retrieve the specific checksum line; fail if missing.
          matched=$(grep -m1 "shfmt_${SHFMT_VERSION}_linux_amd64" /tmp/sha256sums.txt) || {
            printf "Error: Checksum entry not found for version %s\n" "${SHFMT_VERSION}"
            exit 1
          }

          # Map upstream filename to local 'shfmt' binary using canonical format.
          echo "$matched" | awk '{print $1 "  shfmt"}' > /usr/local/bin/shfmt.sha256

          # Verify integrity.
          (cd /usr/local/bin && sha256sum -c shfmt.sha256) || {
            printf "Error: Checksum verification failed.\n"
            exit 1
          }

          chmod +x /usr/local/bin/shfmt
          printf "shfmt installed and validated successfully.\n"

      - name: Run ShellCheck and shfmt
        shell: bash
        run: |
          set -eo pipefail

          _temp_list=$(mktemp)

          # Discovery loop: recursively find files ending in .sh or containing a shell shebang.
          # Excludes hidden directories (e.g., .git).
          while IFS= read -r -d '' file; do
            # Skip non-regular files.
            [ -f "$file" ] || continue

            # Match by extension.
            if [[ "$file" == *.sh ]]; then
              printf '%s\0' "$file" >> "$_temp_list"
              continue
            fi

            # Match by shebang (sh or bash).
            if head -n1 "$file" | grep -qE '^#!.*\b(sh|bash)\b'; then
              printf '%s\0' "$file" >> "$_temp_list"
            fi
          done < <(find . -type f -not -path '*/.*' -print0)

          if [ ! -s "$_temp_list" ]; then
            printf "No shell scripts found. Skipping checks.\n"
            exit 0
          fi

          printf "Target scripts for analysis:\n"
          tr '\0' '\n' < "$_temp_list"

          # 1. Static Analysis (ShellCheck)
          printf "\n--- Running ShellCheck ---\n"
          xargs -0 shellcheck -x -f gcc < "$_temp_list" || {
            printf "Error: ShellCheck detected issues.\n"
            exit 1
          }

          # 2. Formatting Check (shfmt)
          # Flags: -d (diff), -i 2 (indent), -ci (case indent), -bn (binary ops start line).
          printf "\n--- Verifying Code Formatting (shfmt) ---\n"
          xargs -0 shfmt -d -i 2 -ci -bn < "$_temp_list" || {
            printf "Error: Formatting inconsistencies detected.\n"
            printf "Run locally: shfmt -w -i 2 -ci -bn src/ test/\n"
            exit 1
          }

          printf "\nSuccess: All quality checks passed.\n"
          rm "$_temp_list"
